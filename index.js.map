{"version":3,"file":"index.js","sourceRoot":"","sources":["src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { HTMLRewriter as BaseHTMLRewriter, DocumentHandlers, ElementHandlers } from \"html-rewriter-wasm\";\n\ntype SelectorElementHandlers = [selector: string, handlers: ElementHandlers];\n\nconst kEnableEsiTags = Symbol(\"kEnableEsiTags\");\n\n// noinspection SuspiciousTypeOfGuard\nexport class HTMLRewriter {\n  readonly #elementHandlers: SelectorElementHandlers[] = [];\n  readonly #documentHandlers: DocumentHandlers[] = [];\n  [kEnableEsiTags] = false;\n\n  on(selector: string, handlers: ElementHandlers): this {\n    this.#elementHandlers.push([selector, handlers]);\n    return this;\n  }\n\n  onDocument(handlers: DocumentHandlers): this {\n    this.#documentHandlers.push(handlers);\n    return this;\n  }\n\n  transform(response: Response): Response {\n    const body = response.body as ReadableStream<Uint8Array> | null;\n    // HTMLRewriter doesn't run the end handler if the body is null, so it's\n    // pointless to setup the transform stream.\n    if (body === null) return new Response(body, response);\n\n    if (response instanceof Response) {\n      // Make sure we validate chunks are BufferSources and convert them to\n      // Uint8Arrays as required by the Rust glue code.\n      response = new Response(response.body, response);\n    }\n\n    let rewriter: BaseHTMLRewriter;\n    const transformStream = new TransformStream<Uint8Array, Uint8Array>({\n      start: async (controller) => {\n        // Create a rewriter instance for this transformation that writes its\n        // output to the transformed response's stream. Note that each\n        // BaseHTMLRewriter can only be used once. Importing html-rewriter-wasm\n        // will also synchronously compile a WebAssembly module, so delay doing\n        // this until we really need it.\n        // TODO: async compile the WebAssembly module\n        rewriter = new BaseHTMLRewriter(\n          (output) => {\n            // enqueue will throw on empty chunks\n            if (output.length !== 0) controller.enqueue(output);\n          },\n          { enableEsiTags: this[kEnableEsiTags] }\n        );\n        // Add all registered handlers\n        for (const [selector, handlers] of this.#elementHandlers) {\n          rewriter.on(selector, handlers);\n        }\n        for (const handlers of this.#documentHandlers) {\n          rewriter.onDocument(handlers);\n        }\n      },\n      // The finally() below will ensure the rewriter is always freed.\n      // chunk is guaranteed to be a Uint8Array as we're using the\n      // @miniflare/core Response class, which transforms to a byte stream.\n      transform: (chunk) => rewriter.write(chunk),\n      flush: () => rewriter.end(),\n    });\n    const promise = body.pipeTo(transformStream.writable);\n    promise.catch(() => {}).finally(() => rewriter.free());\n\n    // Return a response with the transformed body, copying over headers, etc\n    const res = new Response(transformStream.readable, response);\n    // If Content-Length is set, it's probably going to be wrong, since we're\n    // rewriting content, so remove it\n    res.headers.delete(\"Content-Length\");\n    return res;\n  }\n}\n\nexport function withEnableEsiTags(rewriter: HTMLRewriter): HTMLRewriter {\n  rewriter[kEnableEsiTags] = true;\n  return rewriter;\n}"]}